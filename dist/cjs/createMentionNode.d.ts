import { LexicalEditor, LexicalNodeReplacement } from "lexical";
import { EditorConfig } from "lexical/LexicalEditor";
import React, { ElementType } from "react";
import { BeautifulMentionComponentProps } from "./BeautifulMentionsPluginProps";
import { SerializedBeautifulMentionNode } from "./MentionNode";
export type CustomBeautifulMentionNodeClass = ReturnType<typeof generateClass>;
export declare let CustomBeautifulMentionNode: CustomBeautifulMentionNodeClass;
/**
 * Instead of using the default `BeautifulMentionNode` class, you can
 * extend it and use the mention component of your choice.
 */
export declare function createBeautifulMentionNode(mentionComponent: ElementType<BeautifulMentionComponentProps>): [CustomBeautifulMentionNodeClass, LexicalNodeReplacement];
declare function generateClass(mentionComponent: ElementType<BeautifulMentionComponentProps>): {
    new (trigger: string, triggerRegExp: string, value: string, data?: {
        [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
    }, key?: import("lexical").NodeKey): {
        exportJSON(): SerializedBeautifulMentionNode;
        component(): ElementType<BeautifulMentionComponentProps> | null;
        decorate(editor: LexicalEditor, config: EditorConfig): React.JSX.Element;
        __trigger: string;
        __triggerRegExp: string;
        __value: string;
        __data?: {
            [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
        };
        createDOM(): HTMLElement;
        updateDOM(): boolean;
        exportDOM(): import("lexical").DOMExportOutput;
        getTextContent(): string;
        getTrigger(): string;
        getTriggerRegExp(): string;
        getValue(): string;
        setValue(value: string): void;
        getData(): {
            [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
        } | undefined;
        setData(data?: {
            [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
        }): void;
        getCssClassesFromTheme(config: EditorConfig): {
            className: string | undefined;
            classNameFocused: string | undefined;
            classNames: import("./theme").BeautifulMentionsCssClassNames | undefined;
        };
        constructor: import("lexical").KlassConstructor<{
            new (key?: import("lexical").NodeKey): import("lexical").DecoratorNode<React.JSX.Element>;
            getType(): string;
            clone(_data: unknown): import("lexical").LexicalNode;
            importDOM?: () => import("lexical").DOMConversionMap<any> | null;
            importJSON(_serializedNode: import("lexical").SerializedLexicalNode): import("lexical").LexicalNode;
            transform(): ((node: import("lexical").LexicalNode) => void) | null;
        }>;
        isIsolated(): boolean;
        isInline(): boolean;
        isKeyboardSelectable(): boolean;
        __type: string;
        __key: string;
        __parent: null | import("lexical").NodeKey;
        __prev: null | import("lexical").NodeKey;
        __next: null | import("lexical").NodeKey;
        getType(): string;
        isAttached(): boolean;
        isSelected(selection?: null | import("lexical").BaseSelection): boolean;
        getKey(): import("lexical").NodeKey;
        getIndexWithinParent(): number;
        getParent<T extends import("lexical").ElementNode>(): T | null;
        getParentOrThrow<T extends import("lexical").ElementNode>(): T;
        getTopLevelElement(): import("lexical").ElementNode | null;
        getTopLevelElementOrThrow(): import("lexical").ElementNode;
        getParents(): Array<import("lexical").ElementNode>;
        getParentKeys(): Array<import("lexical").NodeKey>;
        getPreviousSibling<T extends import("lexical").LexicalNode>(): T | null;
        getPreviousSiblings<T extends import("lexical").LexicalNode>(): Array<T>;
        getNextSibling<T extends import("lexical").LexicalNode>(): T | null;
        getNextSiblings<T extends import("lexical").LexicalNode>(): Array<T>;
        getCommonAncestor<T extends import("lexical").ElementNode = import("lexical").ElementNode>(node: import("lexical").LexicalNode): T | null;
        is(object: import("lexical").LexicalNode | null | undefined): boolean;
        isBefore(targetNode: import("lexical").LexicalNode): boolean;
        isParentOf(targetNode: import("lexical").LexicalNode): boolean;
        getNodesBetween(targetNode: import("lexical").LexicalNode): Array<import("lexical").LexicalNode>;
        isDirty(): boolean;
        getLatest(): any;
        getWritable(): any;
        getTextContentSize(): number;
        remove(preserveEmptyParent?: boolean): void;
        replace<N extends import("lexical").LexicalNode>(replaceWith: N, includeChildren?: boolean): N;
        insertAfter(nodeToInsert: import("lexical").LexicalNode, restoreSelection?: boolean): import("lexical").LexicalNode;
        insertBefore(nodeToInsert: import("lexical").LexicalNode, restoreSelection?: boolean): import("lexical").LexicalNode;
        isParentRequired(): boolean;
        createParentElementNode(): import("lexical").ElementNode;
        selectStart(): import("lexical").RangeSelection;
        selectEnd(): import("lexical").RangeSelection;
        selectPrevious(anchorOffset?: number, focusOffset?: number): import("lexical").RangeSelection;
        selectNext(anchorOffset?: number, focusOffset?: number): import("lexical").RangeSelection;
        markDirty(): void;
    };
    getType(): string;
    clone(node: {
        exportJSON(): SerializedBeautifulMentionNode;
        component(): ElementType<BeautifulMentionComponentProps> | null;
        decorate(editor: LexicalEditor, config: EditorConfig): React.JSX.Element;
        __trigger: string;
        __triggerRegExp: string;
        __value: string;
        __data?: {
            [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
        };
        createDOM(): HTMLElement;
        updateDOM(): boolean;
        exportDOM(): import("lexical").DOMExportOutput;
        getTextContent(): string;
        getTrigger(): string;
        getTriggerRegExp(): string;
        getValue(): string;
        setValue(value: string): void;
        getData(): {
            [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
        } | undefined;
        setData(data?: {
            [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
        }): void;
        getCssClassesFromTheme(config: EditorConfig): {
            className: string | undefined;
            classNameFocused: string | undefined;
            classNames: import("./theme").BeautifulMentionsCssClassNames | undefined;
        };
        constructor: import("lexical").KlassConstructor<{
            new (key?: import("lexical").NodeKey): import("lexical").DecoratorNode<React.JSX.Element>;
            getType(): string;
            clone(_data: unknown): import("lexical").LexicalNode;
            importDOM?: () => import("lexical").DOMConversionMap<any> | null;
            importJSON(_serializedNode: import("lexical").SerializedLexicalNode): import("lexical").LexicalNode;
            transform(): ((node: import("lexical").LexicalNode) => void) | null;
        }>;
        isIsolated(): boolean;
        isInline(): boolean;
        isKeyboardSelectable(): boolean;
        __type: string;
        __key: string;
        __parent: null | import("lexical").NodeKey;
        __prev: null | import("lexical").NodeKey;
        __next: null | import("lexical").NodeKey;
        getType(): string;
        isAttached(): boolean;
        isSelected(selection?: null | import("lexical").BaseSelection): boolean;
        getKey(): import("lexical").NodeKey;
        getIndexWithinParent(): number;
        getParent<T extends import("lexical").ElementNode>(): T | null;
        getParentOrThrow<T extends import("lexical").ElementNode>(): T;
        getTopLevelElement(): import("lexical").ElementNode | null;
        getTopLevelElementOrThrow(): import("lexical").ElementNode;
        getParents(): Array<import("lexical").ElementNode>;
        getParentKeys(): Array<import("lexical").NodeKey>;
        getPreviousSibling<T extends import("lexical").LexicalNode>(): T | null;
        getPreviousSiblings<T extends import("lexical").LexicalNode>(): Array<T>;
        getNextSibling<T extends import("lexical").LexicalNode>(): T | null;
        getNextSiblings<T extends import("lexical").LexicalNode>(): Array<T>;
        getCommonAncestor<T extends import("lexical").ElementNode = import("lexical").ElementNode>(node: import("lexical").LexicalNode): T | null;
        is(object: import("lexical").LexicalNode | null | undefined): boolean;
        isBefore(targetNode: import("lexical").LexicalNode): boolean;
        isParentOf(targetNode: import("lexical").LexicalNode): boolean;
        getNodesBetween(targetNode: import("lexical").LexicalNode): Array<import("lexical").LexicalNode>;
        isDirty(): boolean;
        getLatest(): any;
        getWritable(): any;
        getTextContentSize(): number;
        remove(preserveEmptyParent?: boolean): void;
        replace<N extends import("lexical").LexicalNode>(replaceWith: N, includeChildren?: boolean): N;
        insertAfter(nodeToInsert: import("lexical").LexicalNode, restoreSelection?: boolean): import("lexical").LexicalNode;
        insertBefore(nodeToInsert: import("lexical").LexicalNode, restoreSelection?: boolean): import("lexical").LexicalNode;
        isParentRequired(): boolean;
        createParentElementNode(): import("lexical").ElementNode;
        selectStart(): import("lexical").RangeSelection;
        selectEnd(): import("lexical").RangeSelection;
        selectPrevious(anchorOffset?: number, focusOffset?: number): import("lexical").RangeSelection;
        selectNext(anchorOffset?: number, focusOffset?: number): import("lexical").RangeSelection;
        markDirty(): void;
    }): {
        exportJSON(): SerializedBeautifulMentionNode;
        component(): ElementType<BeautifulMentionComponentProps> | null;
        decorate(editor: LexicalEditor, config: EditorConfig): React.JSX.Element;
        __trigger: string;
        __triggerRegExp: string;
        __value: string;
        __data?: {
            [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
        };
        createDOM(): HTMLElement;
        updateDOM(): boolean;
        exportDOM(): import("lexical").DOMExportOutput;
        getTextContent(): string;
        getTrigger(): string;
        getTriggerRegExp(): string;
        getValue(): string;
        setValue(value: string): void;
        getData(): {
            [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
        } | undefined;
        setData(data?: {
            [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
        }): void;
        getCssClassesFromTheme(config: EditorConfig): {
            className: string | undefined;
            classNameFocused: string | undefined;
            classNames: import("./theme").BeautifulMentionsCssClassNames | undefined;
        };
        constructor: import("lexical").KlassConstructor<{
            new (key?: import("lexical").NodeKey): import("lexical").DecoratorNode<React.JSX.Element>;
            getType(): string;
            clone(_data: unknown): import("lexical").LexicalNode;
            importDOM?: () => import("lexical").DOMConversionMap<any> | null;
            importJSON(_serializedNode: import("lexical").SerializedLexicalNode): import("lexical").LexicalNode;
            transform(): ((node: import("lexical").LexicalNode) => void) | null;
        }>;
        isIsolated(): boolean;
        isInline(): boolean;
        isKeyboardSelectable(): boolean;
        __type: string;
        __key: string;
        __parent: null | import("lexical").NodeKey;
        __prev: null | import("lexical").NodeKey;
        __next: null | import("lexical").NodeKey;
        getType(): string;
        isAttached(): boolean;
        isSelected(selection?: null | import("lexical").BaseSelection): boolean;
        getKey(): import("lexical").NodeKey;
        getIndexWithinParent(): number;
        getParent<T extends import("lexical").ElementNode>(): T | null;
        getParentOrThrow<T extends import("lexical").ElementNode>(): T;
        getTopLevelElement(): import("lexical").ElementNode | null;
        getTopLevelElementOrThrow(): import("lexical").ElementNode;
        getParents(): Array<import("lexical").ElementNode>;
        getParentKeys(): Array<import("lexical").NodeKey>;
        getPreviousSibling<T extends import("lexical").LexicalNode>(): T | null;
        getPreviousSiblings<T extends import("lexical").LexicalNode>(): Array<T>;
        getNextSibling<T extends import("lexical").LexicalNode>(): T | null;
        getNextSiblings<T extends import("lexical").LexicalNode>(): Array<T>;
        getCommonAncestor<T extends import("lexical").ElementNode = import("lexical").ElementNode>(node: import("lexical").LexicalNode): T | null;
        is(object: import("lexical").LexicalNode | null | undefined): boolean;
        isBefore(targetNode: import("lexical").LexicalNode): boolean;
        isParentOf(targetNode: import("lexical").LexicalNode): boolean;
        getNodesBetween(targetNode: import("lexical").LexicalNode): Array<import("lexical").LexicalNode>;
        isDirty(): boolean;
        getLatest(): any;
        getWritable(): any;
        getTextContentSize(): number;
        remove(preserveEmptyParent?: boolean): void;
        replace<N extends import("lexical").LexicalNode>(replaceWith: N, includeChildren?: boolean): N;
        insertAfter(nodeToInsert: import("lexical").LexicalNode, restoreSelection?: boolean): import("lexical").LexicalNode;
        insertBefore(nodeToInsert: import("lexical").LexicalNode, restoreSelection?: boolean): import("lexical").LexicalNode;
        isParentRequired(): boolean;
        createParentElementNode(): import("lexical").ElementNode;
        selectStart(): import("lexical").RangeSelection;
        selectEnd(): import("lexical").RangeSelection;
        selectPrevious(anchorOffset?: number, focusOffset?: number): import("lexical").RangeSelection;
        selectNext(anchorOffset?: number, focusOffset?: number): import("lexical").RangeSelection;
        markDirty(): void;
    };
    importJSON(serializedNode: SerializedBeautifulMentionNode): {
        exportJSON(): SerializedBeautifulMentionNode;
        component(): ElementType<BeautifulMentionComponentProps> | null;
        decorate(editor: LexicalEditor, config: EditorConfig): React.JSX.Element;
        __trigger: string;
        __triggerRegExp: string;
        __value: string;
        __data?: {
            [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
        };
        createDOM(): HTMLElement;
        updateDOM(): boolean;
        exportDOM(): import("lexical").DOMExportOutput;
        getTextContent(): string;
        getTrigger(): string;
        getTriggerRegExp(): string;
        getValue(): string;
        setValue(value: string): void;
        getData(): {
            [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
        } | undefined;
        setData(data?: {
            [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
        }): void;
        getCssClassesFromTheme(config: EditorConfig): {
            className: string | undefined;
            classNameFocused: string | undefined;
            classNames: import("./theme").BeautifulMentionsCssClassNames | undefined;
        };
        constructor: import("lexical").KlassConstructor<{
            new (key?: import("lexical").NodeKey): import("lexical").DecoratorNode<React.JSX.Element>;
            getType(): string;
            clone(_data: unknown): import("lexical").LexicalNode;
            importDOM?: () => import("lexical").DOMConversionMap<any> | null;
            importJSON(_serializedNode: import("lexical").SerializedLexicalNode): import("lexical").LexicalNode;
            transform(): ((node: import("lexical").LexicalNode) => void) | null;
        }>;
        isIsolated(): boolean;
        isInline(): boolean;
        isKeyboardSelectable(): boolean;
        __type: string;
        __key: string;
        __parent: null | import("lexical").NodeKey;
        __prev: null | import("lexical").NodeKey;
        __next: null | import("lexical").NodeKey;
        getType(): string;
        isAttached(): boolean;
        isSelected(selection?: null | import("lexical").BaseSelection): boolean;
        getKey(): import("lexical").NodeKey;
        getIndexWithinParent(): number;
        getParent<T extends import("lexical").ElementNode>(): T | null;
        getParentOrThrow<T extends import("lexical").ElementNode>(): T;
        getTopLevelElement(): import("lexical").ElementNode | null;
        getTopLevelElementOrThrow(): import("lexical").ElementNode;
        getParents(): Array<import("lexical").ElementNode>;
        getParentKeys(): Array<import("lexical").NodeKey>;
        getPreviousSibling<T extends import("lexical").LexicalNode>(): T | null;
        getPreviousSiblings<T extends import("lexical").LexicalNode>(): Array<T>;
        getNextSibling<T extends import("lexical").LexicalNode>(): T | null;
        getNextSiblings<T extends import("lexical").LexicalNode>(): Array<T>;
        getCommonAncestor<T extends import("lexical").ElementNode = import("lexical").ElementNode>(node: import("lexical").LexicalNode): T | null;
        is(object: import("lexical").LexicalNode | null | undefined): boolean;
        isBefore(targetNode: import("lexical").LexicalNode): boolean;
        isParentOf(targetNode: import("lexical").LexicalNode): boolean;
        getNodesBetween(targetNode: import("lexical").LexicalNode): Array<import("lexical").LexicalNode>;
        isDirty(): boolean;
        getLatest(): any;
        getWritable(): any;
        getTextContentSize(): number;
        remove(preserveEmptyParent?: boolean): void;
        replace<N extends import("lexical").LexicalNode>(replaceWith: N, includeChildren?: boolean): N;
        insertAfter(nodeToInsert: import("lexical").LexicalNode, restoreSelection?: boolean): import("lexical").LexicalNode;
        insertBefore(nodeToInsert: import("lexical").LexicalNode, restoreSelection?: boolean): import("lexical").LexicalNode;
        isParentRequired(): boolean;
        createParentElementNode(): import("lexical").ElementNode;
        selectStart(): import("lexical").RangeSelection;
        selectEnd(): import("lexical").RangeSelection;
        selectPrevious(anchorOffset?: number, focusOffset?: number): import("lexical").RangeSelection;
        selectNext(anchorOffset?: number, focusOffset?: number): import("lexical").RangeSelection;
        markDirty(): void;
    };
    importDOM(): import("lexical").DOMConversionMap | null;
    transform(): ((node: import("lexical").LexicalNode) => void) | null;
};
export {};
